# 全面分析ZNS SSD在高性能缓存解决方案中的应用

## 1. 执行摘要

分区命名空间（Zoned Namespace, ZNS）SSD 作为一种新兴的存储技术，通过其独特的架构和操作模式，为解决传统SSD在缓存等写密集型应用中面临的挑战提供了新的途径。本报告旨在全面调研ZNS SSD的最新研究进展，并深入分析其作为缓存应用的可行性、优势、挑战及实现策略。

核心研究表明，ZNS SSD通过将存储空间划分为必须顺序写入的“区域（Zone）”，并将数据放置和垃圾回收（GC）等关键管理任务转移到主机端，从而显著降低了写放大（WA）、减少了设备内部的过度配置（OP）需求，并提升了服务质量（QoS）和设备耐久性。这些特性使其在理论上非常适合写操作频繁、对延迟敏感的缓存应用。

以Z-CacheLib为代表的最新研究成果展示了ZNS SSD在缓存场景下的巨大潜力，实现了比传统SSD缓存方案更高的吞吐量、更低的写放大和相当的缓存命中率。同时，诸如oZNS、ReZNS等技术分别针对ZNS的小写入性能和能效进行了优化，进一步增强了ZNS SSD的适用性。Zone Append命令等NVMe ZNS规范特性也为提升并发写入性能提供了重要支持。

然而，ZNS SSD的应用并非没有挑战。主机端软件复杂性的增加是其最显著的特点之一。缓存系统需要重新设计其数据放置、更新、逐出和垃圾回收逻辑，以适应顺序写约束和分区管理模型。特别是对于小写入和大规模分区的管理，需要精巧的策略来避免性能瓶颈。

生态系统方面，Linux内核、SPDK以及相关的库和工具链对ZNS的支持日趋成熟，为开发者提供了构建ZNS感知型应用的基础。但与传统块设备相比，针对特定应用（如缓存）的高度优化解决方案仍处于发展阶段。

本报告综合分析认为，尽管存在实现复杂性，ZNS SSD凭借其在性能、耐久性和成本效益方面的固有优势，是构建下一代高性能、大容量缓存系统的有力候选者。成功的ZNS缓存部署依赖于对ZNS特性深刻理解基础上的系统级协同设计，包括缓存算法的适配、高效的主机端GC机制以及对小写入和并发的智能管理。随着技术的不断成熟和生态的持续完善，ZNS SSD有望在数据中心和企业级存储的缓存层中发挥越来越重要的作用。

## 2. 分区命名空间 (ZNS) SSD 简介

分区命名空间 (Zoned Namespace, ZNS) SSD 代表了固态存储领域的一项重要革新，它通过引入一种新的主机与设备协作模式，旨在克服传统SSD在特定工作负载下（尤其是写密集型应用）所面临的性能、耐久性和成本效益等方面的挑战。

### 2.1. ZNS 技术的核心原理

ZNS SSD 的核心设计理念根植于对NAND闪存物理特性的深刻理解和高效利用。其关键原理包括：

- **基于区域的架构 (Zone-Based Architecture):** ZNS SSD将其逻辑地址空间划分为固定大小、粗粒度的区域（Zones）。这是对传统SSD线性块寻址方式的根本性改变。这种分区结构旨在与NAND闪存的内部特性（特别是擦除块大小）对齐，从而实现更高效的介质管理 。每个区域可以被独立寻址和管理。  
    
- **顺序写约束 (Sequential Write Constraint):** 在每个区域内，数据必须从该区域的写指针（Write Pointer）位置开始顺序写入 。不允许对区域内任意位置进行随机写入。这一约束是ZNS诸多优势的基石，它直接映射了NAND闪存的底层写入要求（即在同一物理块内，数据页必须顺序编程），从而简化了设备内部的操作。任何非写指针位置的写入尝试（即乱序写入）都将导致错误 。  
    
- **区域状态与管理 (Zone States and Management):** 区域在主机的管理下会经历多种状态转换，例如空（Empty）、隐式打开（Implicit Open）、显式打开（Explicit Open）、关闭（Closed）、满（Full）、只读（Read-Only）和离线（Offline）。主机软件必须理解并正确管理这些状态，以确保I/O操作的正确执行和资源的高效利用。例如，一个区域必须处于“打开”状态才能接受写入，并且设备对同时处于打开或活动状态的区域数量存在限制 。  
    
- **区域重置操作 (Zone Reset Operation):** 若要重新写入一个区域，主机必须首先显式地对其执行重置操作。该操作会擦除区域内的所有数据，并将写指针移回区域的起始位置 。这相当于ZNS环境下的垃圾回收，但其发起和管理权完全交由主机，赋予了主机对数据回收的控制能力。  
    
- **区域容量与区域大小 (Zone Capacity vs. Zone Size):** ZNS引入了“区域容量（Zone Capacity）”的概念，指区域内可用的逻辑块数量，它可以小于“区域大小（Zone Size）”（区域内总的逻辑块数量）。这种设计允许区域大小保持为2的幂次方（便于逻辑块地址到区域号的转换），同时能够优化区域存储容量与底层介质特性（例如非2的幂次方的擦除块大小）的映射 。这有助于优化与闪存擦除块的对齐，而无需设备端进行复杂的管理，确保了NAND的有效利用。对超出区域容量的逻辑块地址的写访问将导致错误 。  
    

### 2.2. 与传统 SSD 的关键区别

ZNS SSD与传统SSD在架构和工作方式上存在显著差异，这些差异是理解ZNS优势和挑战的关键：

- **主机透明的闪存转换层 (FTL) 的缺失:** 传统SSD依赖FTL来透明地处理逻辑到物理地址的映射、磨损均衡和垃圾回收。相比之下，ZNS SSD将大部分数据放置的智能转移到了主机端 。SSD本身仍然负责介质的可靠性管理 。这种转变减轻了SSD控制器内部的复杂度和资源需求（如DRAM和处理能力）。  
    
- **主机管理的垃圾回收 (GC):** 在ZNS模型中，主机负责执行GC操作，包括识别待回收的“受害者”区域，可能需要迁移其中的有效数据，然后重置这些区域 。传统SSD的内部GC是设备自主行为，其执行时机和持续时间对主机不可预知，可能导致性能抖动 。主机管理的GC允许应用程序在合适的时机（例如系统空闲时）调度GC操作，从而可能减少对关键工作负载的性能干扰。  
    
- **为GC而设的过度配置 (OP) 的消除:** 传统SSD通常需要预留相当一部分存储空间（7-28%甚至更多 ）作为OP，用于内部GC操作和磨损均衡。由于主机接管了空间回收的管理，ZNS SSD几乎消除了设备层面为GC而设的OP需求 。这使得在相同的原始NAND闪存容量下，ZNS SSD能提供更高的可用容量，从而提高成本效益 。  
    

### 2.3. ZNS SSD 的固有优势

基于其核心原理和与传统SSD的区别，ZNS SSD展现出一系列固有优势：

- **降低写放大 (WA):** 通过强制执行与闪存特性相符的顺序写入，并将GC移至主机端，ZNS显著减少了设备级别的写放大 。更低的WA意味着对NAND闪存的编程/擦除（P/E）周期消耗更少，从而延长了SSD的寿命，并带来更可预测的写入性能。  
    
- **最小化过度配置:** 如前所述，这带来了更高的可用容量和更低的每GB成本 。用户购买的NAND闪存中，更大部分可用于实际数据存储。  
    
- **增强的服务质量 (QoS) / 可预测的延迟:** 消除了不可预测的设备端GC操作，使得ZNS SSD能够提供更稳定、更低的I/O延迟，尤其是尾延迟，这对于读取操作尤为重要 。这对于延迟敏感型应用（如缓存系统）至关重要。  
    
- **提升耐久性:** 写放大的降低直接有助于延长SSD的使用寿命 。这使得ZNS SSD更有潜力应用于写密集型工作负载（如缓存），尤其是在采用QLC等高密度但耐久性较低的NAND闪存时 。  
    
- **更高的吞吐量:** 优化的数据放置策略和简化的设备内部管理有助于实现更高的持续写入吞吐量 。设备将更少的时间用于内部管理任务，而将更多时间用于服务主机请求。  
    

ZNS技术的核心在于主机与存储设备之间责任分工的根本性转变。虽然ZNS_设备_本身变得更简单（FTL功能减弱，无需为数据放置执行内部GC），但_主机软件_的复杂性却显著增加。这不仅仅是采用新API的问题，它要求主机系统（操作系统、文件系统或如缓存管理器之类的应用程序）具备“闪存感知”能力，并显式管理数据放置、GC和写入顺序。例如，文献中常提及ZNS“显著简化了驱动器架构”，这指的是设备本身。整个系统的复杂性可能并未减少，而是转移到了主机软件栈。这种转变赋予了主机更大的控制权，可以利用这种控制权进行特定应用的优化（例如在缓存中），但这需要付出更高的开发成本，并且需要更复杂的主机软件栈 。  

顺序写约束是ZNS实现其优势（如减少WA、更好地与NAND物理特性对齐）的基石。然而，它也是将ZNS集成到现有软件栈以及处理非固有顺序性工作负载（如许多缓存更新模式）时的主要挑战。NAND闪存固有地要求块内页面顺序写入，并且块在重写前必须被擦除 。ZNS在区域层面强制执行此规则 ，最大限度地减少了主机与设备之间的阻抗失配，从而降低了WA并提升了性能/耐久性 。然而，包括具有频繁小更新或随机插入的缓存系统在内的许多应用程序，并不能自然地产生纯顺序的写操作流。适配这些工作负载需要在主机层面采用诸如日志结构化、缓冲等技术，或利用Zone Append等特性来管理并发的小型写入 。此约束直接影响数据的布局方式、GC的执行方式以及缓存逐出策略的设计。对于单个区域的标准写入操作，“QD=1”的限制 是此约束与可能重排I/O的堆栈结合时的直接后果。  

## 3. 利用 ZNS SSD 进行缓存：详细分析

将ZNS SSD应用于缓存系统，旨在利用其独特的架构特性来克服传统SSD在处理缓存工作负载时遇到的性能瓶颈和耐久性问题。缓存工作负载通常具有高并发、写密集和对延迟敏感的特点，这使得ZNS SSD的潜在优势尤为突出。

### 3.1. ZNS 在缓存工作负载中的应用原理

将ZNS SSD用于缓存的合理性主要基于以下几点：

- **缓存的写密集特性:** 缓存工作负载，特别是对于写回缓存（Write-Back Cache）或具有高流失率（Churn Rate）的缓存，通常是写密集和更新密集的 。传统SSD在这种工作负载下会因内部GC而产生严重的WA和性能下降 。ZNS通过减少WA并将GC控制权交给主机，使其在处理这类工作负载时具有天然吸引力 。  
    
- **主机控制对缓存管理的益处:** 主机（即缓存管理软件）可以智能地将具有相似特征（例如生命周期、访问模式）的数据放置到不同的区域中 。这种数据共存（Co-location）策略可以简化缓存的GC过程。当一个区域主要包含冷数据或已失效的缓存条目时，可以通过简单的区域重置操作来回收空间，而只需迁移少量有效数据，从而直接提高缓存效率并降低GC开销 。  
    
- **利用可预测性:** ZNS SSD由于消除了设备端GC，其性能表现（尤其是延迟）更为可预测 。这对于延迟敏感的缓存应用至关重要，因为一致的缓存响应时间是保障整体应用性能的关键。  
    

### 3.2. 对缓存的性能影响

ZNS SSD对缓存系统的性能可能产生多方面积极影响：

- **吞吐量和延迟优势:**
    
    - 通过优化的数据放置和最小化的设备内部开销，ZNS SSD有望实现更高的持续写入吞吐量 。例如，Z-CacheLib的研究报告称，与在常规SSD上运行的CacheLib相比，其吞吐量提高了多达2倍 。  
        
    - 由于没有设备驱动的GC干扰，ZNS SSD可以提供更低且更可预测的读写延迟，尤其是尾延迟 。在ZNS上运行的RocksDB实验显示，其99.9百分位的随机读取延迟降低了2-4倍 。  
        
    - 对于缓存而言，这意味着更快的缓存填充速度、更迅速的缓存条目检索以及在负载下更一致的性能表现。
- **对缓存命中率的影响:**
    
    - ZNS本身并不直接提高缓存命中率。然而，高效的GC和可能更大的可用缓存容量可以通过允许缓存更多条目，或减少因设备级效率低下导致的不必要逐出，间接支持更高的命中率。Z-CacheLib的研究显示命中率提高了5% 。  
        
    - 如果GC效率低下并迫使有效缓存数据过早逐出，缓存命中率会受到影响。主机控制允许实现缓存感知的GC策略。

### 3.3. 缓存的耐久性和成本效益

对于需要长期运行且成本敏感的缓存系统，ZNS SSD在耐久性和成本效益方面也显示出优势：

- **提升耐久性:** 写放大的显著降低（Z-CacheLib报告WA接近1 ）延长了SSD的使用寿命，使其更适合写密集型缓存应用 。这对于在缓存中使用更高密度但耐久性较低的NAND闪存（如QLC）尤为重要 。缓存由于新数据的准入和更新，通常会经历高写入速率。降低WA意味着对于相同数量的逻辑缓存数据，底层NAND单元经历的P/E周期更少。  
    
- **成本效益 (更低的 $/GB):** 由于减少了对过度配置的需求，每个设备的可用容量得以增加 。与需要大量OP的传统SSD相比，这使得ZNS SSD能以相同成本提供更大的缓存容量，或以更低成本提供相同的缓存容量。  
    

### 3.4. 容量优势：最大化可用缓存空间

通过消除设备端的过度配置，ZNS SSD可将容量提高7-28% 。对于缓存层而言，这直接转化为存储更多数据的能力，从而可能在不增加物理设备数量或原始NAND容量的情况下提高命中率和整体应用性能。  

### 3.5. ZNS 缓存的基础挑战

尽管ZNS SSD为缓存应用带来了诸多益处，但也引入了一些必须解决的基础挑战：

- **使缓存逻辑适应顺序写入和区域管理:**
    
    - 传统的缓存算法（如LRU、LFU、ARC）通常假设可以对缓存条目进行随机访问以进行更新和逐出。这些算法需要针对ZNS的顺序写约束和基于区域的擦除进行重大调整或重新设计 。  
        
    - 例如，更新位于区域中间的缓存条目是不可能的。该条目必须被标记为无效，并且新版本必须顺序写入，很可能写入不同的区域，或者如果空间允许，则写入同一区域的后续位置。这使得某些缓存设计中常见的原地更新（in-place update）语义复杂化。
- **针对缓存数据的主机端垃圾回收 (GC) 策略:**
    
    - 缓存管理器必须实现自己的GC逻辑。这包括选择“受害者”区域，将这些区域中仍然有效的（仍然是热点的）缓存条目迁移到新的区域，然后重置受害者区域 。  
        
    - 这种主机端GC增加了复杂性，如果设计不当，其本身也可能引入性能开销。GC的效率至关重要。
- **管理缓存逐出的大区域粒度:**
    
    - ZNS区域可能很大（例如，96MiB到1077MiB ）。逐出数据通常意味着回收整个区域。如果一个区域混合了热点和冷点缓存条目，过早回收该区域会逐出热点数据，而延迟回收则会导致空间利用率低下 。  
        
    - 这需要采取诸如将具有相似生命周期的数据分组到同一区域，或在区域内实现更细粒度的GC（这会增加复杂性）等策略。
- **解决小写入性能问题:**
    
    - 缓存元数据更新或小型缓存对象可能导致小写入。标准的ZNS写入模型可能会受到每个区域队列深度较低（QD=1）的困扰，从而降低小写入的性能 。  
        
    - 需要诸如Zone Append 之类的解决方案，或专门的SSD固件/设计（如oZNS ）来缓解此问题。  
        

主机管理的GC对缓存而言是一把“双刃剑”。虽然它提供了控制和可预测性方面的优势，但如果未能针对特定的缓存工作负载进行高效实现，也会引入显著的设计复杂性和潜在的性能瓶颈。在缓存上下文中，“垃圾”仅仅是指不再有用或已被逐出的数据。ZNS将GC责任转移给主机 ，对缓存而言，这意味着缓存逐出逻辑与GC紧密交织。其益处在于，缓存可以决定_何时_进行GC（例如，在空闲期间）以及对_什么_进行GC（例如，具有最高逐出/冷数据比例的区域），从而避免了设备GC带来的不可预测的停顿 。然而，挑战在于，如果回收一个混合了热点和冷点数据的区域，主机现在必须执行有效缓存条目的实际数据迁移 。这会消耗主机CPU、内存带宽和SSD带宽，如果优化不当，可能会抵消ZNS的部分优势。大区域尺寸 加剧了这个问题：回收一个1GB的区域，即使只有10%的有效数据，也意味着需要移动100MB的数据，这并非无足轻重。因此，有效的ZNS缓存需要复杂的主机端GC机制，这些机制应具备缓存感知能力，通过智能地初始放置数据（按生命周期共存）和明智地选择受害者区域来最大限度地减少数据迁移。  

在ZNS中，“缓存更新”的概念也发生了根本性的改变。在DRAM缓存甚至传统SSD缓存（由FTL抽象）中常见的缓存条目原地更新，在ZNS中不复存在。ZNS缓存中的“更新”通常意味着将旧条目标记为无效，并顺序写入新版本，类似于日志结构化方法。这是因为ZNS区域是仅顺序写入的，并且需要重置才能重写 。如果缓存条目 `X`（位于区域 `Z` 的LBA `L` 处）需要更新为 `X'`，则 `X'` 不能写入 `L`。缓存系统必须：(a) 将 `X'` 写入新位置（如果空间和顺序性允许，则写入区域 `Z` 的后续位置，或者写入新的活动区域 `Z'`）；(b) 更新其元数据以指向 `X'` 的新位置；(c) 将位于 `L` 的旧 `X` 标记为无效。这种非原地更新机制是ZNS设计的固有部分，它与日志结构化数据管理非常吻合，但要求缓存系统采用类似的原则。这影响了缓存元数据的管理方式、空闲空间的跟踪方式以及逐出候选者的选择方式，因为“脏”条目不仅仅是停留在原地，而是会产生新的写入。  

此外，容量与管理开销之间存在权衡。虽然ZNS因无设备OP而提供更高的可用容量 ，但主机可能需要实现其自身形式的“逻辑”过度配置或非常仔细地管理空间，以便有效地处理主机端GC，特别是对于具有高流失率的缓存。ZNS SSD为宿主提供了更多的原始容量 。然而，主机端GC需要空闲空间来写入来自受害者区域的有效数据，然后才能重置这些区域 。如果缓存在非常高的利用率（例如，>95%满）下运行，主机GC将只有很少的空闲区域可供迁移数据，从而导致高GC压力、增加的数据移动（主机级别的WA）以及潜在的性能下降。这类似于FTL在高利用率下遇到的困难。因此，ZNS缓存系统可能需要将一定百分比的区域保持为“空”或“为GC保留”，这充当了一种主机级别的过度配置形式（如Z-CacheLib中的vOP ）。这意味着，如果要在大写入负载下保持高性能，_有效可用缓存容量_可能小于总的ZNS命名空间容量。这种权衡从设备OP转向了主机管理的逻辑OP。  

下表总结了ZNS SSD与传统SSD在缓存应用中的关键特性对比：

**表1: ZNS SSD 与传统 SSD 在缓存应用中的对比**

|特性|ZNS SSD 特征|传统 SSD 特征|对缓存的影响 (ZNS的优缺点)|
|---|---|---|---|
|**FTL**|主机部分参与或感知，设备FTL简化|设备内部复杂FTL，对主机透明|**优点:** 主机可优化数据放置，减少设备开销。**缺点:** 增加主机软件复杂性。|
|**GC**|主机管理|设备内部自动GC，不可预测|**优点:** GC时机可控，可与缓存策略协同，减少性能抖动。**缺点:** 主机需实现复杂GC逻辑，可能产生自身开销。|
|**过度配置 (OP)**|设备级OP极少或无需|需要显著OP (7-28%+)|**优点:** 更高可用容量，更低$/GB，可缓存更多数据。**缺点:** 主机可能仍需逻辑OP以保证GC效率。|
|**写入机制**|区域内顺序写入|逻辑上随机写入，物理上由FTL管理|**优点:** 与NAND特性匹配，天然低WA。**缺点:** 对非顺序缓存更新模式构成挑战，需适配缓存算法。|
|**主机控制**|对数据放置、GC有高度控制权|有限控制（如TRIM指令）|**优点:** 可实现应用感知的存储管理，优化缓存性能。**缺点:** 对主机软件要求高。|
|**数据放置**|主机可按生命周期等策略将数据共置于区域|FTL决定物理放置，主机影响有限|**优点:** 优化GC效率，减少数据迁移。**缺点:** 需要应用或缓存层具备智能放置能力。|
|**耐久性管理**|主要通过减少WA提升耐久性，设备仍负责底层磨损均衡|FTL负责磨损均衡和坏块管理|**优点:** 主机行为可进一步延长寿命。**缺点:** 主机不当的写入模式可能（理论上）影响局部磨损。|
|**小写入处理**|标准写入QD=1限制，Zone Append或oZNS可缓解|FTL缓冲和合并小写入|**优点:** Zone Append等机制可提升并发。**缺点:** 基础模型对小写入不友好，是缓存元数据更新的挑战。|
|**读取可预测性**|由于无设备GC，读取延迟更可预测|可能受GC影响导致延迟抖动|**优点:** 对延迟敏感的缓存命中操作非常有利。|

 

## 4. ZNS 缓存技术的前沿研究

针对ZNS SSD在缓存应用中的潜力与挑战，学术界和工业界已展开深入研究，提出了一系列创新技术和优化方案。这些研究主要集中在如何设计ZNS感知的缓存引擎、优化写性能、改进缓存算法以及提升整体系统效率。

### 4.1. Z-CacheLib：一个面向区域优化的闪存缓存引擎

Z-CacheLib被提出作为一个专门为ZNS SSD设计的、经过区域存储优化的闪存缓存引擎，旨在解决传统缓存在ZNS上可能遇到的吞吐量、写放大（WA）和命中率等问题 。它被认为是首个可重用、可插拔的ZNS SSD闪存缓存引擎 。  

- **架构:**
    - **zStorage Engine:** 该引擎直接在ZNS SSD上管理CacheLib的I/O单元（通常称为region）。其设计目标是实现低映射开销和低操作开销，支持并行写入，并解决文件系统可能引入的块I/O转换和复杂映射开销问题 。  
    - **zCache Engine:** 该引擎实现了针对垃圾回收（GC）的跨层优化，并引入了新颖的逐出策略 。  
        
- **关键创新点:**
    
    - **虚拟过度配置 (Virtual Over-Provisioning, vOP):** 引入vOP概念，用于驱动和设计区域感知的逐出策略 。vOP很可能指的是一种主机管理的预留空间机制，用以促进高效的GC和数据迁移，这在处理大尺寸区域时尤为关键。  
    - **zLRU (Zone-aware LRU):** 一种基于区域信息的积极逐出策略，旨在减少GC开销 。这表明它是一种LRU（最近最少使用）的变体，但其操作粒度更粗，或在逐出决策中考虑了区域状态/填充度。  
    - **zDrop (GC-aware eviction policy):** 一种自下而上的逐出策略 。该策略可能优先从那些适合回收的区域（例如，包含很少有效缓存项的区域）中逐出数据，以最小化GC成本。  
        
- **性能基准:**
    - 与在传统SSD上运行的CacheLib相比，Z-CacheLib可实现高达2倍的吞吐量和5%的命中率提升 。  
    - 写放大几乎为零（WA因子接近1）。  
    - 与基于F2FS的ZNS方案相比，吞吐量提升高达6倍，WA降低92% 。  
    - Z-CacheLib能够在保持LRU级别命中率的同时，达到FIFO级别的性能 。  
    - 这些数据有力地证明，当ZNS与像Z-CacheLib这样的专用缓存引擎结合使用时，其在缓存工作负载下的性能可以显著优于传统SSD以及在ZNS上使用通用文件系统的方法。
### 4.2. 优化缓存的写入性能——oZNS
由于缓存系统（尤其是元数据更新或小对象缓存）可能产生大量小IO，而ZNS的基础写入模型对小IO支持不佳，因此优化写入性能，特别是小IO写入性能，是ZNS缓存研究的重点。
- **oZNS (Orderless ZNS SSD):** 该研究旨在解决Linux I/O栈中的无序写入可能违反ZNS顺序写约束的问题。这种约束通常迫使每个区域的写入队列深度（QD）限制为1，从而严重降低小写入性能 。  
    - **机制:** oZNS允许向一个区域提交多个写请求，并在SSD内部进行乱序处理。它采用了一个轻量级的间接层、针对写偏差的内存高效元数据结构，以及一个双层缓冲机制（数据写入缓冲区和元数据缓冲区）来管理这一过程 。此外，一种“读取尝试（read-try）”策略通过将元数据访问移出读取关键路径来提高读取效率 。  
        
    - **影响:** oZNS声称其小写入性能比传统ZNS高出8.6倍，同时保持相当的读取性能 。对于缓存应用而言，oZNS可以缓解这些操作的性能瓶颈，使ZNS更适用于更广泛的缓存工作负载。  
        
- **Zone Append 命令:** 这是NVMe ZNS规范中定义的一个命令，允许主机向区域追加数据而无需指定确切的偏移量。设备负责在当前区域写指针处写入数据，并返回实际写入的LBA 。  
    
    - **益处:** 它允许向同一区域提交多个未完成的写命令，从而提高了并行度和吞吐量，尤其对于小写入操作。这是通过将这些追加写入的写指针管理任务卸载到设备端实现的 。这有助于克服标准区域写入的QD=1限制。  
    - **对缓存的影响:** 对于缓存填充操作至关重要，因为此时可能需要将多个小缓存项并发写入缓存中的活动“追加”区域。ZWALs（Zone Append友好的WAL）利用此特性优化LSM-tree在ZNS上的WAL操作，据称可将吞吐量提高多达33% 。  
### 4.3. 能源与性能优化：ReZNS
ReZNS（Renewable-Zoned Namespace）是一种针对ZNS SSD的能量和性能优化映射机制，它通过回收区域中未使用的容量来减少昂贵的区域重置操作 。  
- **机制:** 当收到区域重置请求时，如果该区域仍有大量剩余容量（例如，超过25%），ReZNS会将其标记为“可再生区域（Rzone）”并放入一个“备用列表（spare-list）”，而不是立即执行擦除操作。新的区域创建请求可以优先复用这些Rzone。此外，一个守护进程负责处理“僵尸区域”（即应用程序终止时无意中遗留的空闲打开区域），而ReGC机制则管理备用列表的大小 。  
- **影响:** ReZNS据称可将整体性能提高多达60%，并将总功耗降低多达3%（其中区域重置命令的功耗可降低高达64%）。  
- **对缓存的影响:** 对于具有高流失率的缓存工作负载，频繁的区域重置可能成为开销。ReZNS有潜力通过允许部分填充的区域（例如，在一些缓存项被逐出后）被快速复用于新的缓存条目而无需完全重置，从而减少这种开销，提高写入性能和能源效率。如果缓存逐出并不总是与完整的区域回收完美对齐，这一点尤其重要。
### 4.4. 针对 ZNS 的高级缓存算法与策略
将传统缓存算法应用于ZNS环境，或为ZNS设计全新的缓存策略，是当前研究的热点。
- **调整传统算法 (LRU, LFU, ARC):**
    - **挑战:** 顺序写约束、大区域粒度以及主机管理的GC使得LRU、LFU、ARC等传统算法难以直接应用 。例如，在LRU列表中提升一个条目或在LFU中增加一个频率计数，如果涉及到数据移动，在ZNS中代价高昂。基于严格LRU/LFU的逐出可能会选中位于区域中间的数据，而这些数据在不重置整个区域或进行复杂数据迁移的情况下无法回收。  
    - **Z-CacheLib的zLRU:** 这是LRU适应ZNS的一个例子，它通过使其区域感知，基于区域信息积极逐出区域 。这暗示了一种混合方法，其中LRU原则应用于更粗的粒度或与区域状态结合使用。  
    - **LFU的考量:** LFU倾向于保留历史上流行的条目 ，如果这些条目所在的区域因包含其他较少使用但近期更活跃的条目而成为回收目标，则可能产生问题。在LFU中，通常使用LRU来打破平局 。朴素LFU中寻找最低计数的O(n)扫描 也是一个性能隐患。  
    - **ARC的考量:** ARC平衡了新近度（LRU）和频率（LFU），并使用幽灵列表（ghost lists）。调整ARC将涉及使其MRU/MFU列表管理和幽灵列表跟踪与基于区域的操作兼容。ARC的“扫描抵抗性” 可能对缓存工作负载有益。  
- **区域感知的逐出策略和数据共存:**
    - **概念:** 将具有相似生命周期或访问模式的数据分组到同一区域是一项关键策略 。这使得整个区域可以同时“变冷”，从而使GC（区域重置）非常高效，只需迁移极少的有效数据。  
    - **Prophet (用于ZNS上的LSM-KV):** 通过预测SST文件的生命周期来实现数据共存，据称可将WA降低多达31% 。虽然这是针对键值存储的，但基于生命周期的数据放置原则直接适用于缓存。  
    - **WA-Zone (用于ZNS上的LSM-tree):** 动态地将具有不同热度的数据分配给具有相应生命周期的区域，以平衡磨损 。这与缓存的耐久性相关。  
    - **对缓存的影响:** 对于缓存而言，这意味着尝试预测哪些缓存项将大约在同一时间被逐出，并将它们写入同一区域。这具有挑战性，但对GC效率的回报很高。
- **ZNS 缓存中的预取策略:**
    - 通用的预取技术旨在在数据被访问之前将其加载到缓存中 。对于ZNS，预取到缓存仍涉及对区域的顺序写入。  
    - **相关性:** 虽然现有文献讨论了通用SSD 或CXL-SSD（如ExPAND ）的预取，但专门针对ZNS缓存特性（如利用基于区域的知识或与顺序写入协调）进行优化的预取算法在所提供的材料中并未深入详述，这表明这可能是一个需要进一步研究的领域，或者需要更细致地应用现有原则。ZNSCCACHE论文 在未命中时会获取对象的所有剩余数据，这本身就是一种预取形式。  
    - 灵活数据放置（FDP）被提及作为ZNS的一种替代方案，旨在降低软件工程成本，允许主机提供数据放置提示以减少诸如CacheLib等缓存中的WA 。这突显了行业在数据放置方面朝着主机-设备协作的趋势发展，与ZNS类似。  
        
- **ZNS 缓存中的写回策略:**
    
    - **挑战:** 由于顺序写约束，管理ZNS缓存中的脏数据需要谨慎处理。脏数据无法原地更新。
    - **机制:** 写回操作将涉及累积脏数据，然后将其顺序写入某个区域。如果这些数据最终要持久化到存储中，则类似于缓存填充。如果是对已缓存条目的更新，则属于非原地更新。
    - ReZNS 在此可能相关，如果脏数据被写入Rzones。  
    - 针对ZNS的选择性PLP（掉电保护） 专注于通过修改ZNS写命令以传递PLP启用请求，来确保WAL/日志等关键数据的持久性。对于写回缓存，确保缓存的脏数据在掉电期间被正确刷新或保护至关重要。研究表明，ZNS SSD可能需要更大的写缓冲区来支持多个I/O流，这增加了对PLP电容的需求，而选择性PLP旨在减少这种需求。  
    - ACE（非对称并发感知逐出） 提出并发感知的写回策略，即并发写入多个脏页面以利用设备并行性，这与高效填充区域的目标一致。  
        
### 4.5. 与缓存概念相关的专用 ZNS 应用

一些针对特定场景的ZNS应用研究，其设计理念和技术手段对ZNS缓存的实现也具有借鉴意义。

- **用于交换管理的 ZNSage:** ZNSage通过采用硬件无关的元数据管理（在系统内存中）和GC优化（最小化交换区回收期间的页错误），优化了ZNS SSD上的交换（swap）性能 。 
- **与缓存的相关性:** 交换本质上是一种操作系统级别的磁盘缓存。ZNSage管理具有确定生命周期的数据（交换页）并高效执行GC的技术，与ZNS缓存面临的挑战在概念上是相似的。其硬件无关的元数据管理方法是一个宝贵的经验。
- **用于ZNS SSD的ZapRAID:** ZapRAID是一个为ZNS SSD设计的高性能日志结构化RAID系统，它利用Zone Append实现写入并行性，并采用轻量级条带管理。它采用基于组的数据布局和混合数据管理（Zone Append + Zone Write）来实现区域内和区域间的并行性 **与缓存的相关性:** 对于可能需要多个ZNS SSD来满足容量和性能需求的大规模缓存系统，ZapRAID管理数据分布和在ZNS设备间实现并行性的方法，可以为分布式ZNS缓存的架构设计提供参考。其对Zone Append的性能运用也直接相关。

有效的ZNS缓存不仅仅是简单地调整旧算法，更需要一种“协同设计（Co-design）”的方法。在这种方法中，缓存逻辑、数据放置策略、GC机制，甚至应用层关于数据生命周期的提示，都必须紧密集成并感知ZNS基于区域的、顺序写入的特性。Z-CacheLib 正是这种理念的体现。传统缓存通常在块级粒度上操作，由于FTL的抽象，它们在很大程度上忽略了底层的闪存几何结构。而ZNS暴露了区域特性 ，其顺序写规则和大的区域擦除粒度意味着缓存操作（插入、逐出、更新、GC）都具有直接的物理放置影响。像Z-CacheLib这样的研究 明确设计了“zStorage Engine”和“zCache Engine”，并采用了“跨层优化”。这表明需要摆脱缓存逻辑独立于存储细节的模块化设计。诸如vOP、zLRU和zDrop等技术 本质上就是区域感知的。数据共存策略 要求缓存理解数据语义（生命周期）并将其映射到区域放置。ZNS在缓存应用上的成功取决于这种深度集成，它超越了简单的API采用，需要进行整体系统设计。  

尽管ZNS在处理顺序工作负载方面表现出色，但高效处理小写入（在缓存元数据更新、小对象缓存中很常见）仍然是一个反复出现的主题和重大障碍。这推动了命令集层面的Zone Append以及设备/固件层面的oZNS等创新。标准写入的每区域QD=1限制 使得ZNS在处理频繁、非协调的小写入时效率低下。缓存系统经常产生此类小写入（例如，更新缓存索引、写入小的键值对）。Zone Append 允许将多个小写入排队到同一区域，由设备处理顺序化，从而提高并发性和吞吐量。这是一种命令集级别的解决方案。而oZNS 则代表了设备级的架构变更，允许向区域进行乱序提交，并在内部进行重排序/管理，专门用于提升小写入性能。这些解决方案的存在和持续研究突显了ZNS并非万能药；其核心模型需要增强才能有效处理常见的、非理想的工作负载组件，以扩大其在缓存中的适用性。  

对于ZNS而言，像ZenFS这样的专用文件系统 或像Z-CacheLib这样的直接面向ZNS的缓存管理器 ，实际上承担了传统上由更通用的文件系统或FTL处理的角色。这表明，为了获得最佳性能，像缓存这样的应用程序可能会完全绕过通用文件系统，或者使用非常轻量级的、ZNS感知的文件系统。传统文件系统在块设备上运行会增加其自身的抽象层和开销。而ZNS的显式控制优势在应用程序（或一个紧密相关的层）直接管理数据放置时才能得到最大化。ZenFS被设计为“一个用户空间文件系统……与RocksDB兼容……将数据放置到分区存储设备上”，具有高度的专用性。Z-CacheLib则提出了一个“zStorage Engine”来_直接_管理ZNS SSD上的区域，以避免文件系统开销 。这一趋势表明，要充分利用ZNS进行缓存，更直接的访问模型（可能将最少的文件系统功能，如缓存对象的元数据管理，集成到缓存本身中）比将其分层构建在可能未针对特定缓存访问模式进行优化的通用ZNS文件系统之上更为可取。  

下表总结了ZNS缓存解决方案中的关键研究成果：

**表2: ZNS 缓存解决方案关键研究总结**

| 研究/技术                   | 核心机制                                                                     | 对缓存的主要益处 (吞吐量, WA, 命中率, 延迟, 耐久性, 容量, 能效)                                 | 主要解决的挑战/局限性                               |
| ----------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------ | ----------------------------------------- |
| **Z-CacheLib**          | 专为ZNS设计的缓存引擎，包含zStorage Engine和zCache Engine；采用vOP、zLRU、zDrop等区域感知策略。    | 吞吐量提升 (高达2x vs 常规SSD, 高达6x vs ZNS-F2FS)，WA接近1，命中率提升 (5%)，FIFO级性能LRU级命中率。 | 传统缓存不兼容ZNS，ZNS大区域GC效率，缓存指标权衡。             |
| **oZNS**                | 允许向区域提交多个写请求并由SSD内部乱序处理；采用轻量级间接层、写偏差元数据、双层缓冲和读取尝试策略。                     | 小写入性能大幅提升 (高达8.6x vs 传统ZNS)，读取性能相当。                                      | ZNS标准写模型下，因IO栈乱序特性导致的每区域QD=1限制，严重影响小写入性能。 |
| **ReZNS**               | 回收区域中未使用的容量以减少区域重置；将有较多剩余容量的待重置区域标记为Rzone并放入备用列表供复用。                     | 整体性能提升 (高达60%)，总功耗降低 (高达3%)，区域重置功耗大幅降低。                                  | ZNS中频繁的区域重置操作带来的性能和能效开销，尤其是在高流失率缓存中。      |
| **Zone Append (缓存上下文)** | NVMe ZNS命令，允许主机向区域追加数据而无需指定精确偏移，设备负责写入并返回实际LBA。                          | 提升并发写入能力，尤其对小写入，克服QD=1限制，提高吞吐量。对缓存填充操作有利。                                | 标准区域写入的串行化限制。                             |
| **ZNSage (交换管理)**       | 硬件无关的交换元数据管理 (存于系统内存)，优化GC (最小化交换区回收时的页错误)。                              | 提升交换性能，适用于任何ZNS SSD。概念上对ZNS缓存的元数据管理和GC有借鉴意义。                             | 传统基于SSD的交换性能不佳，先前ZNS交换方案存在硬件依赖。           |
| **ZapRAID (ZNS RAID)**  | 日志结构化RAID，利用Zone Append实现写入并行，采用组数据布局和混合数据管理 (Zone Append + Zone Write)。 | 提高ZNS RAID阵列的写入吞吐量和并行性。其Zone Append应用和并行管理思路对大规模分布式ZNS缓存有参考价值。           | 在ZNS SSD阵列上实现高效可靠的RAID。                   |
|                         |                                                                          |                                                                          |                                           |


