#Cache #缓存准入

[本地PDF](obsidian://open?vault=md&file=3_Lab%2F%E3%80%90Cache%E3%80%91%E3%80%90%E7%BC%93%E5%AD%98%E5%87%86%E5%85%A5%E3%80%91%E3%80%90wanghua%E3%80%91%E3%80%90ICPP%202018%E3%80%91.pdf)


## 介绍
以下是文章《Efficient SSD Caching by Avoiding Unnecessary Writes using Machine Learning》的模型和推理部分的简洁提炼，基于用户的需求。

---

### **模型**
文章提出了一种基于**决策树**（Decision Tree）的分类器，用于预测照片是否为一次性访问，以优化SSD缓存性能。

- **分类器**：  
  - 使用**决策树**作为核心模型。  
  - **原因**：决策树在准确性（85.99%）和计算开销之间平衡良好，AUC为0.8986，优于朴素贝叶斯、神经网络等其他算法。  
  - **配置**：最大分裂次数限制为30，树高通常为5，预测只需5次比较，避免过拟合且高效。

- **特征**：  
  - **照片所有者社交信息**：活跃朋友数、所有者照片平均查看次数。  
  - **照片信息**：类型（12种）、大小、年龄（上传时间距今）、最近访问时间。  
  - **缓存系统信息**：终端类型（PC/移动设备）、最近请求数、访问时间（小时级别）。  
  - **特征选择**：通过**信息增益**选出关键特征，如平均查看次数、照片访问最近性等。

- **训练**：  
  - **离线训练**：每天凌晨5点，使用前24小时数据训练，采用CART算法，训练时间仅几分钟，确保适应动态工作负载。

---

### **推理**
文章通过定义“一次性访问标准”和分类系统，推理照片是否需要写入缓存。

- **一次性访问标准**：  
  - **基本定义**：照片在追踪期内只访问一次（约61.5%）。  
  - **改进定义**：包括缓存停留期间不再访问的照片，即使整个追踪期内可能多次访问。

- **再访问距离 \( M \)**：  
  - **定义**：照片写入缓存后到下次访问之间的连续访问次数。  
  - **计算**：通过迭代公式 \( M = \frac{C}{S(1 - h)(1 - p)} \) 计算，其中：  
    - \( C \)：缓存大小  
    - \( S \)：平均照片大小  
    - \( h \)：缓存命中率  
    - \( p \)：一次性访问照片比例（初始值为0.615，迭代3次收敛）。  

- **分类系统**：  
  - **架构**：包括决策树分类器和历史表。  
  - **工作流程**：  
    1. 缓存命中：直接返回数据。  
    2. 缓存未命中：请求后端存储。  
    3. 后端返回数据给分类器。  
    4. 分类器预测：若为一次性访问，直接返回客户端不写入缓存，并更新历史表；若非一次性访问，写入缓存并返回。  
  - **历史表**：记录一次性访问照片的元数据，优化后续预测。

- **成本敏感学习**：  
  - **目的**：减少误判非一次性访问为一次性访问的代价（导致后续未命中）。  
  - **方法**：调整分类阈值，倾向预测为非一次性访问，降低假阳性率。



### **总结**
- **模型**：决策树分类器，利用社交网络和缓存相关的多维特征，每天离线训练，高效预测一次性访问照片。  
- **推理**：通过改进的一次性访问标准和再访问距离计算，结合分类系统动态判断照片是否写入缓存，优化性能。

该方法显著提高了缓存命中率（+17%）、减少SSD写入（65%-81%）、降低访问延迟（7.5%），验证了其有效性。

---


# 如何打标签？

是的，我已经阅读了你提供的文章，特别是标题为《Efficient SSD Caching by Avoiding Unnecessary Writes using Machine Learning》中关于“One-Time-Access Criteria”（一次性访问标准）的第4.3节。下面我将为你详细解释文章中关于训练数据标签的内容。

---

### 训练数据标签的背景和目的
在文章中，作者试图解决一个问题：如何在SSD缓存系统中识别出“一次性访问”（one-time-access）的照片，以避免不必要的写入操作。这些一次性访问的照片指的是：
- 只被访问一次的照片；
- 或者即使被多次访问，但由于缓存容量有限，在缓存中停留期间不会再次被访问的照片。

通过机器学习，作者希望训练一个模型来预测哪些照片属于“一次性访问”，从而决定是否将它们写入缓存。为了实现这一点，训练数据需要被正确地标注（labeled），以便模型能够学习区分一次性访问和非一次性访问的照片。

---

### 训练数据标签的核心概念

#### 1. **一次性访问的定义**
- **基本标准（Rudimentary Criteria）**  
  最初，作者将整个追踪期间只被访问一次的照片定义为一次性访问照片。在文章提到的QQPhoto日志中，大约61.5%的照片属于这一类，占总访问量的25.5%。
- **改进标准（Sophisticated Criteria）**  
  更精确的定义不仅包括只访问一次的照片，还包括那些即使被多次访问，但由于缓存大小限制，在缓存中停留期间不会再次被访问的照片。这是因为这些照片可能在下一次访问前已经被替换出缓存，缓存它们并无意义。

#### 2. **再访问距离（Reaccess Distance, M）**
- **定义**  
  再访问距离 \( M \) 是指一张照片被写入缓存后，到它下一次被访问之间经历的连续访问次数。
- **作用**  
  如果 \( M \) 超过某个阈值，说明这张照片在缓存中停留期间不太可能被再次访问，因此可以被标注为一次性访问照片。

#### 3. **阈值 \( M \) 的计算**
为了确定哪些照片是“一次性访问”的，作者提出了一个模型来计算 \( M \) 的阈值，基于以下参数：
- \( h \)：缓存命中率（cache hit rate）；
- \( C \)：缓存容量（cache size）；
- \( S \)：平均照片大小（average photo size）；
- \( p \)：一次性访问照片的百分比（percentage of one-time-access files）。

- **初步公式**  
  假设缓存满时，替换次数等于未命中次数：
  $$M(1 - h) = \frac{C}{S}$$
  因此：
  $$M = \frac{C}{S(1 - h)}$$

- **改进公式**  
  但由于并不是所有未命中的照片都会进入缓存（因为有排除策略），作者进一步调整公式，考虑一次性访问照片比例 \( p \)：
  $M(1 - h)(1 - p) = \frac{C}{S}$
  因此：
  $$
  M = \frac{C}{S(1 - h)(1 - p)}
 $$

- **迭代计算 \( p \)**  
  因为 \( p \) 和 \( M \) 相互影响，作者采用迭代方法：
  1. 从初始估计值开始（例如，追踪分析中的 \( p = 0.615 \)）。
  2. 根据公式计算 \( M \)。
  3. 用 \( M \) 重新标注照片，计算新的 \( p \)。
  4. 重复此过程，直到 \( p \) 收敛（通常3次迭代即可）。

#### 4. **如何标注照片**
训练数据标签的赋值过程如下：
- **只访问一次的照片**  
  这些照片直接被标注为“一次性访问”（正标签）。
- **多次访问的照片**  
  计算它们的再访问距离 \( M \)。如果最小的 \( M \) 大于阈值，则标注为“一次性访问”；否则标注为“非一次性访问”（负标签）。

---

### 标签赋值的具体流程
1. **数据标记**  
   - 对于每张照片，检查其访问记录。
   - 只访问一次的，直接标记为“一次性访问”。
   - 多次访问的，计算其再访问距离 \( M \)，与阈值比较后标记。
2. **迭代调整**  
   - 初始 \( p \) 来自追踪数据（例如61.5%）。
   - 用 \( M \) 标注照片后，重新统计一次性访问照片的比例，更新 \( p \)。
   - 重复直到 \( p \) 稳定。

---

### 标签的作用
这些标签的最终目的是为机器学习模型（文中使用的是决策树）提供训练数据。通过准确的标签，模型可以：
- 学习一次性访问照片的特征和模式；
- 在实际运行中预测新访问的照片是否为一次性访问；
- 帮助缓存系统决定是否将照片写入缓存，从而减少不必要的写入操作，提升性能。

---

### 总结
简单来说，文章中的训练数据标签是用来区分“一次性访问”和“非一次性访问”照片的工具。标签的赋值基于：
- 是否只访问一次；
- 对于多次访问的照片，是否在缓存停留期间无法再次被访问（通过再访问距离 \( M \) 判断）。

通过迭代计算阈值 \( M \) 并标注数据，作者确保训练数据准确反映了缓存系统的实际情况。这种方法让机器学习模型能够有效预测哪些照片不值得缓存，从而优化SSD的性能。

希望这个解释清楚地回答了你的问题！如果还有疑问，欢迎继续提问。